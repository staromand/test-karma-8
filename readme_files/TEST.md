[< Назад к оглавлению](../README.md)

___

#### Внимание! Все данные, вносимые в БД, теряются после перезапуска контейнера mysql

## Трансформация БД

Чтобы проверить изменение БД от исходного состояния к состоянию ожидающемуся, нужно будет запустить либо по очереди, либо сразу обе миграции.
После запуска первой можно будет увидеть изначальное состояние БД, а после запуска второй – то, к которому я пришёл

  1. Перед запуском миграций нужно сначала войти в контейнер php-fpm
     ```bash
     docker compose exec php-fpm bash
     ```
  2. Затем выполнить команду:
     - Для запуска только первой миграции:
       ```bash
       bin/console doctrine:migrations:migrate "DoctrineMigrations\Version20231125191916" --no-interaction
       ```
     - Для запуска сразу всех миграций до последней версии:
       ```bash
       bin/console doctrine:migrations:migrate --no-interaction
       ```
  3. Для удобства тестирования я подготовил небольшой датасет. Для того чтобы его распаковать, нужно выйти из контейнера
     и запустить из консоли скрипт `restore_dataset.sh`, лежащий в корне проекта:
     ```bash
     ./restore_dataset.sh
     ```
     После этого в БД появится одна тысяча пользователей и где-то 20% подписок для них со сроком истечения от 0 до 30 дней от текущего момента

## Логика

### Мои соображения насчёт проекта

1. За валидные e-mail я принял также и те, что считаются `confirmed`, из-за того, что:
   - мы с вами в ТЗ условились, что валидация дорогая
   - раз пользователь уже получал на этот ящик письмо с подтверждением, значит, e-mail точно валидный
   - особого сценария валидации в ТЗ не указано, поэтому считаем, что на сервис рассылки e-mail как на валидатор полагаться можно
   - оберегаем пространство и вычислительные ресурсы СУБД от избыточных данных и лишних индексов

2. В моём проекте подразумевается, что поля `confirmed_email`, `valid_email` и `checked_email` автоматически устанавливаются в `true` сразу
   же как только пользователь подтверждает e-mail через свою почту

3. Условился сам с собой, что если у юзера подписка истекает, то она не продляется, но создаётся новая. Поэтому для одной подписки может быть
   только один жизненный цикл с точки зрения оповещений за 1 и за 3 дня.

4. В ТЗ ничего не нашёл про сценарии использования функции `check_email()`, поэтому работу с ней полностью опустил. В датасете с пользователями есть
   вся необходимая информация для работы остальных компонентов проекта.

5. Пункт из ТЗ, который звучит как "Можно использовать cron", я интерпретировал как "можно подготовить консольные команды для запуска крона, крон в нашей парадигме уместен".
   Поэтому команды я сделал, а крон не настраивал на автоматическое их исполнение. Посему команды придётся запускать руками.

### Вкратце про то, как работает очередь

- Очередь событий по отправке сообщений построил на БД в отдельной таблице `subscription_notification_event`
- Крон-команда `karma8:subscription:generate-events` ходит в таблицу с подписками и отфильтровывает те, что подпадают под правило
  "подписки, истекающие через 1 или 3 дня" с некоторыми доп. условиями

  Запрос тут:
  ```php
  \App\Service\UserSubscriptionService::getAllForNotification()
  ```
- Кладёт в таблицу `subscription_notification_event` все события, которые должны обработаться почтовым сервисом
- Почтовый сервис работает по крону, допустим, раз в минут 5. Отправляет письма и устанавливает флажки `triggered` событиям для обеспечения
  лишь однократного срабатывания

### Запуск очереди событий и почтового обработчика

1. Когда весь датасет загружен в БД, можно запускать команду для проверки истекающих подписок.
   Для этого, находясь внутри контейнера, запускаем команду:
   ```bash
   bin/console karma8:subscription:generate-events
   ```
   Команда отрапортует о своём завершении и после этого можно идти проверять таблицу событий
2. Для отправки сообщений по этим событиям, запускаем команду:
   ```bash
   bin/console karma8:subscription:send-notifications
   ```
   После удачного выполнения команда также отрапортует и заодно обновит записи таблицы `subscription_notification_event`
   в колонке `triggered`

___

[< Назад к оглавлению](../README.md)
